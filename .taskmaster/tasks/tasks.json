{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Express.js Project Structure",
        "description": "Initialize the Express.js application with the required dependencies and project structure for the Telegram bot bridge.",
        "details": "1. Initialize a new Node.js project with `npm init -y`\n2. Install required dependencies:\n   ```bash\n   npm install express axios dotenv helmet cors\n   ```\n3. Create the basic file structure:\n   - `index.js` - Main server file\n   - `.env` - Environment variables\n   - `.env.example` - Template for environment variables\n   - `.gitignore` - Exclude node_modules and .env\n4. Setup basic Express server in index.js:\n   ```javascript\n   require('dotenv').config();\n   const express = require('express');\n   const helmet = require('helmet');\n   const cors = require('cors');\n   \n   const app = express();\n   const PORT = process.env.PORT || 3000;\n   \n   // Middleware\n   app.use(express.json());\n   app.use(helmet());\n   app.use(cors());\n   \n   // Health check endpoint\n   app.get('/health', (req, res) => {\n     res.status(200).json({ status: 'ok' });\n   });\n   \n   app.listen(PORT, () => {\n     console.log(`Server running on port ${PORT}`);\n   });\n   ```\n5. Create .env.example with required variables:\n   ```\n   TELEGRAM_BOT_TOKEN=\n   N8N_WEBHOOK_URL=\n   PORT=3000\n   ```",
        "testStrategy": "1. Verify the server starts without errors\n2. Test the health endpoint with curl or Postman\n3. Confirm environment variables are loaded correctly\n4. Ensure all dependencies are correctly installed and listed in package.json",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Telegram Webhook Endpoint",
        "description": "Create the webhook endpoint to receive messages from the Telegram Bot API.",
        "details": "1. Create a route handler for the Telegram webhook in index.js:\n   ```javascript\n   // Telegram webhook endpoint\n   app.post('/webhook/telegram', async (req, res) => {\n     try {\n       // Validate the incoming request has the expected structure\n       if (!req.body || !req.body.message) {\n         console.error('Invalid request format:', req.body);\n         return res.status(400).send('Invalid request format');\n       }\n       \n       // Extract message data\n       const { message } = req.body;\n       const chatId = message.chat.id;\n       const messageText = message.text;\n       const userId = message.from.id;\n       \n       // Log incoming message\n       console.log(`Received message from ${userId}: ${messageText}`);\n       \n       // Acknowledge receipt to Telegram (important for webhook performance)\n       res.status(200).send('OK');\n       \n       // Process message in a separate function (to be implemented)\n       // This allows us to respond to Telegram quickly while processing continues\n       processMessage(chatId, messageText, userId);\n     } catch (error) {\n       console.error('Error processing webhook:', error);\n       res.status(500).send('Internal server error');\n     }\n   });\n   \n   // Placeholder for the message processing function\n   async function processMessage(chatId, messageText, userId) {\n     // To be implemented in Task 3\n     console.log('Processing message:', messageText);\n   }\n   ```\n2. Add validation for the Telegram Bot token (optional security measure):\n   ```javascript\n   // Validate Telegram requests (optional)\n   function validateTelegramRequest(req, res, next) {\n     const telegramToken = process.env.TELEGRAM_BOT_TOKEN;\n     // Additional validation logic can be added here\n     next();\n   }\n   \n   // Apply middleware to the webhook route\n   app.post('/webhook/telegram', validateTelegramRequest, async (req, res) => {\n     // ... existing code\n   });\n   ```\n3. Add a setup endpoint to register the webhook with Telegram:\n   ```javascript\n   app.get('/setup', async (req, res) => {\n     try {\n       const token = process.env.TELEGRAM_BOT_TOKEN;\n       const url = `https://api.telegram.org/bot${token}/setWebhook?url=${encodeURIComponent(process.env.PUBLIC_URL + '/webhook/telegram')}`;\n       const response = await axios.get(url);\n       res.json(response.data);\n     } catch (error) {\n       console.error('Error setting up webhook:', error);\n       res.status(500).json({ error: error.message });\n     }\n   });\n   ```\n4. Update .env.example to include PUBLIC_URL:\n   ```\n   PUBLIC_URL=https://your-app-url.com\n   ```",
        "testStrategy": "1. Use a tool like ngrok to expose local server for testing\n2. Send test requests to the webhook endpoint using curl or Postman with sample Telegram message format\n3. Verify the endpoint correctly extracts message text, chat ID, and user ID\n4. Test error handling with malformed requests\n5. Verify the setup endpoint successfully registers the webhook with Telegram",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement n8n Webhook Integration",
        "description": "Create the functionality to forward user messages to the existing n8n webhook and process the responses.",
        "details": "1. Implement the HTTP client to send requests to n8n:\n   ```javascript\n   const axios = require('axios');\n   \n   async function forwardToN8n(message, userId) {\n     try {\n       const n8nWebhookUrl = process.env.N8N_WEBHOOK_URL;\n       \n       // Prepare the payload for n8n\n       const payload = {\n         message: message,\n         userId: userId,\n         source: 'telegram'\n       };\n       \n       // Send request to n8n webhook\n       console.log(`Forwarding message to n8n: ${message}`);\n       const response = await axios.post(n8nWebhookUrl, payload, {\n         headers: {\n           'Content-Type': 'application/json'\n         },\n         timeout: 10000 // 10 second timeout\n       });\n       \n       // Return the processed response from n8n\n       return response.data;\n     } catch (error) {\n       console.error('Error forwarding to n8n:', error);\n       // Return error message to be sent back to user\n       if (error.code === 'ECONNABORTED') {\n         return { error: 'timeout', message: 'Request took too long, please try again' };\n       } else if (error.response && error.response.status >= 500) {\n         return { error: 'n8n_down', message: \"I'm having trouble thinking right now, try again in a moment\" };\n       } else {\n         return { error: 'unknown', message: 'An error occurred processing your request' };\n       }\n     }\n   }\n   ```\n2. Update the processMessage function to use the n8n integration:\n   ```javascript\n   async function processMessage(chatId, messageText, userId) {\n     try {\n       // Forward message to n8n\n       const n8nResponse = await forwardToN8n(messageText, userId);\n       \n       // Send response back to user\n       await sendTelegramMessage(chatId, n8nResponse.message || n8nResponse);\n     } catch (error) {\n       console.error('Error in message processing:', error);\n       // Send error message to user\n       await sendTelegramMessage(chatId, \"Sorry, I encountered an error processing your request.\");\n     }\n   }\n   ```\n3. Create a placeholder for the sendTelegramMessage function (to be implemented in Task 4):\n   ```javascript\n   async function sendTelegramMessage(chatId, text) {\n     // To be implemented in Task 4\n     console.log(`Would send to ${chatId}: ${text}`);\n   }\n   ```",
        "testStrategy": "1. Create a mock n8n webhook endpoint for testing\n2. Test the forwardToN8n function with various message inputs\n3. Verify error handling for different failure scenarios:\n   - Timeout\n   - n8n server down\n   - Invalid response format\n4. Check that the correct error messages are returned for each scenario\n5. Validate the payload format matches what n8n expects",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Telegram Response Handler",
        "description": "Create functionality to send processed responses back to users via the Telegram Bot API.",
        "status": "done",
        "dependencies": [
          3
        ],
        "priority": "high",
        "details": "1. Implement the sendTelegramMessage function:\n   ```javascript\n   async function sendTelegramMessage(chatId, text) {\n     try {\n       const token = process.env.TELEGRAM_BOT_TOKEN;\n       const url = `https://api.telegram.org/bot${token}/sendMessage`;\n       \n       // Prepare the payload for Telegram API\n       const payload = {\n         chat_id: chatId,\n         text: text,\n         parse_mode: 'Markdown' // Enable markdown formatting\n       };\n       \n       // Send message to Telegram\n       const response = await axios.post(url, payload);\n       console.log(`Message sent to ${chatId}`);\n       return response.data;\n     } catch (error) {\n       console.error('Error sending Telegram message:', error);\n       // If markdown parsing fails, try sending without markdown\n       if (error.response && error.response.status === 400 && error.response.data.description.includes('parse')) {\n         return sendTelegramMessagePlainText(chatId, text);\n       }\n       throw error;\n     }\n   }\n   \n   // Fallback function for sending plain text (no markdown)\n   async function sendTelegramMessagePlainText(chatId, text) {\n     try {\n       const token = process.env.TELEGRAM_BOT_TOKEN;\n       const url = `https://api.telegram.org/bot${token}/sendMessage`;\n       \n       const payload = {\n         chat_id: chatId,\n         text: text,\n         parse_mode: '' // No parsing\n       };\n       \n       const response = await axios.post(url, payload);\n       console.log(`Plain text message sent to ${chatId}`);\n       return response.data;\n     } catch (error) {\n       console.error('Error sending plain text message:', error);\n       throw error;\n     }\n   }\n   ```\n2. Add support for handling the /start command:\n   ```javascript\n   // Update the processMessage function to handle commands\n   async function processMessage(chatId, messageText, userId) {\n     try {\n       // Handle /start command\n       if (messageText === '/start') {\n         await sendTelegramMessage(chatId, \"Hello! I'm your TON AI Strategist. Ask me any crypto-related questions!\");\n         return;\n       }\n       \n       // Forward message to n8n\n       const n8nResponse = await forwardToN8n(messageText, userId);\n       \n       // Handle n8n response\n       if (n8nResponse.error) {\n         await sendTelegramMessage(chatId, n8nResponse.message);\n       } else {\n         // Parse the n8n response according to the documented format\n         let responseText;\n         if (n8nResponse.results && n8nResponse.results.length > 0 && n8nResponse.results[0].result) {\n           // Extract from the structured n8n response format\n           responseText = n8nResponse.results[0].result;\n         } else if (typeof n8nResponse === 'string') {\n           responseText = n8nResponse;\n         } else {\n           responseText = n8nResponse.message || JSON.stringify(n8nResponse);\n         }\n         \n         await sendTelegramMessage(chatId, responseText);\n       }\n     } catch (error) {\n       console.error('Error in message processing:', error);\n       await sendTelegramMessage(chatId, \"Sorry, I encountered an error processing your request.\");\n     }\n   }\n   ```\n3. Add support for handling long responses:\n   ```javascript\n   // Function to split long messages (Telegram has a 4096 character limit)\n   function splitLongMessage(text, maxLength = 4000) {\n     if (text.length <= maxLength) return [text];\n     \n     const parts = [];\n     let currentPart = '';\n     \n     // Split by paragraphs or sentences to maintain readability\n     const paragraphs = text.split('\\n\\n');\n     \n     for (const paragraph of paragraphs) {\n       if (currentPart.length + paragraph.length + 2 <= maxLength) {\n         currentPart += (currentPart ? '\\n\\n' : '') + paragraph;\n       } else {\n         // If adding a paragraph would exceed max length\n         if (currentPart) {\n           parts.push(currentPart);\n           currentPart = paragraph;\n         } else {\n           // If a single paragraph is too long, split by sentences\n           const sentences = paragraph.split('. ');\n           for (const sentence of sentences) {\n             if (currentPart.length + sentence.length + 2 <= maxLength) {\n               currentPart += (currentPart ? '. ' : '') + sentence;\n             } else {\n               parts.push(currentPart);\n               currentPart = sentence;\n             }\n           }\n         }\n       }\n     }\n     \n     if (currentPart) {\n       parts.push(currentPart);\n     }\n     \n     return parts;\n   }\n   \n   // Update sendTelegramMessage to handle long messages\n   async function sendTelegramMessage(chatId, text) {\n     try {\n       const messageParts = splitLongMessage(text);\n       \n       for (const part of messageParts) {\n         await sendSingleTelegramMessage(chatId, part);\n         // Small delay between messages to maintain order\n         if (messageParts.length > 1) {\n           await new Promise(resolve => setTimeout(resolve, 500));\n         }\n       }\n       \n       return { success: true };\n     } catch (error) {\n       console.error('Error sending message parts:', error);\n       throw error;\n     }\n   }\n   \n   // Function to send a single message\n   async function sendSingleTelegramMessage(chatId, text) {\n     // ... (previous sendTelegramMessage implementation) ...\n   }\n   ```\n\n4. Implement the forwardToN8n function with proper response parsing:\n   ```javascript\n   async function forwardToN8n(messageText, userId) {\n     try {\n       const n8nWebhookUrl = process.env.N8N_WEBHOOK_URL;\n       \n       // Prepare payload for n8n\n       const payload = {\n         message: messageText,\n         userId: userId,\n         source: 'telegram',\n         timestamp: new Date().toISOString()\n       };\n       \n       // Send request to n8n\n       const response = await axios.post(n8nWebhookUrl, payload);\n       \n       // Parse the n8n response according to the documented format\n       if (response.data && response.data.results && \n           response.data.results.length > 0 && \n           response.data.results[0].result) {\n         // Extract from the structured n8n response format\n         return response.data;\n       }\n       \n       // Fallback to other formats if the expected structure isn't found\n       return response.data;\n     } catch (error) {\n       console.error('Error forwarding to n8n:', error);\n       return {\n         error: true,\n         message: \"Sorry, I couldn't process your request at this time.\"\n       };\n     }\n   }\n   ```",
        "testStrategy": "1. Test sending messages to a real Telegram bot using the Bot API\n2. Verify markdown formatting works correctly\n3. Test fallback to plain text when markdown parsing fails\n4. Test handling of the /start command\n5. Verify long messages are correctly split and sent in sequence\n6. Test with various response formats from n8n (string, JSON, error objects)\n7. Verify character escaping for special Markdown characters\n8. Test parsing of the structured n8n response format with the results array\n9. Verify the complete end-to-end flow from user message to n8n processing to response delivery\n10. Test error handling when n8n returns unexpected response formats",
        "subtasks": [
          {
            "id": 4.1,
            "title": "Implement n8n response format parsing",
            "description": "Update the response handling to properly parse the n8n structured output format.",
            "status": "completed"
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement Rate Limiting",
        "description": "Add user-based throttling per Telegram user to prevent abuse of the bot and n8n backend, complementing existing IP-based rate limiting.",
        "status": "done",
        "dependencies": [
          4
        ],
        "priority": "medium",
        "details": "## Background\nWe already have IP-based rate limiting implemented via express-rate-limit middleware (10 req/min per IP). Now we need to add user-based rate limiting to prevent individual Telegram users from overwhelming the system.\n\n## Implementation Steps\n\n1. Create a user-based rate limiter that works alongside our existing IP-based limiter:\n   ```javascript\n   // In-memory store for user rate limits\n   const userRequests = {};\n   \n   // User-specific rate limit configuration\n   const USER_RATE_LIMIT = {\n     windowMs: 60 * 1000, // 1 minute window\n     maxRequests: 5,      // 5 requests per minute\n     message: \"Please wait a moment before asking another question\"\n   };\n   \n   // Check if user has exceeded rate limit\n   function checkUserRateLimit(userId) {\n     const now = Date.now();\n     \n     // Initialize user record if not exists\n     if (!userRequests[userId]) {\n       userRequests[userId] = {\n         count: 0,\n         resetAt: now + USER_RATE_LIMIT.windowMs\n       };\n     }\n     \n     // Reset counter if window has passed\n     if (now >= userRequests[userId].resetAt) {\n       userRequests[userId] = {\n         count: 0,\n         resetAt: now + USER_RATE_LIMIT.windowMs\n       };\n     }\n     \n     // Check if limit exceeded\n     if (userRequests[userId].count >= USER_RATE_LIMIT.maxRequests) {\n       return {\n         limited: true,\n         message: USER_RATE_LIMIT.message,\n         resetAt: userRequests[userId].resetAt\n       };\n     }\n     \n     // Increment counter\n     userRequests[userId].count++;\n     return { limited: false };\n   }\n   ```\n\n2. Integrate user-based rate limiting into the message processing flow (while preserving the existing IP-based limiting):\n   ```javascript\n   // Update processMessage function to include user-based rate limiting\n   async function processMessage(chatId, messageText, userId) {\n     try {\n       // Skip rate limiting for /start command\n       if (messageText !== '/start') {\n         // Check user-specific rate limit\n         const rateLimitCheck = checkUserRateLimit(userId);\n         if (rateLimitCheck.limited) {\n           await sendTelegramMessage(chatId, rateLimitCheck.message);\n           return;\n         }\n       } else {\n         // Handle /start command\n         await sendTelegramMessage(chatId, \"Hello! I'm your TON AI Strategist. Ask me any crypto-related questions!\");\n         return;\n       }\n       \n       // Existing message processing code...\n       const n8nResponse = await forwardToN8n(messageText, userId);\n       // ...\n     } catch (error) {\n       // Error handling...\n     }\n   }\n   ```\n\n3. Add a cleanup mechanism for the in-memory store to prevent memory leaks:\n   ```javascript\n   // Periodically clean up expired rate limit records\n   setInterval(() => {\n     const now = Date.now();\n     for (const userId in userRequests) {\n       if (now >= userRequests[userId].resetAt) {\n         delete userRequests[userId];\n       }\n     }\n   }, 15 * 60 * 1000); // Run every 15 minutes\n   ```\n\n4. Add configurable user rate limit via environment variables:\n   ```javascript\n   // Update .env.example\n   // USER_RATE_LIMIT_WINDOW_MS=60000\n   // USER_RATE_LIMIT_MAX_REQUESTS=5\n   \n   // Update user rate limit configuration\n   const USER_RATE_LIMIT = {\n     windowMs: parseInt(process.env.USER_RATE_LIMIT_WINDOW_MS) || 60 * 1000,\n     maxRequests: parseInt(process.env.USER_RATE_LIMIT_MAX_REQUESTS) || 5,\n     message: \"Please wait a moment before asking another question\"\n   };\n   ```\n\n5. Ensure the user-based rate limiting works in conjunction with the existing IP-based rate limiting middleware.\n<info added on 2025-06-18T18:03:32.197Z>\n## Implementation Status\n\n### Successfully implemented user-based rate limiting feature:\n\n✅ **Implementation Completed:**\n1. **Added user-based rate limiting configuration** with environment variable support:\n   - `USER_RATE_LIMIT_WINDOW_MS=60000` (1 minute window)\n   - `USER_RATE_LIMIT_MAX_REQUESTS=5` (5 requests per minute per user)\n\n2. **Implemented checkUserRateLimit function** that:\n   - Tracks requests per Telegram user ID in memory\n   - Automatically resets counters after the time window\n   - Provides friendly error messages with countdown timer\n   - Works independently from existing IP-based rate limiting\n\n3. **Integrated rate limiting into processMessage function**:\n   - Skips rate limiting for `/start` command (as designed)\n   - Checks user rate limit before processing any other messages\n   - Returns user-friendly message when limit exceeded\n   - Enhanced logging to include user ID for better tracking\n\n4. **Added memory cleanup mechanism**:\n   - Periodic cleanup every 15 minutes to prevent memory leaks\n   - Removes expired user records automatically\n   - Logs cleanup activity for monitoring\n\n5. **Updated environment configuration**:\n   - Added rate limiting variables to `env.example`\n   - Made configuration flexible via environment variables\n   - Maintains backward compatibility with sensible defaults\n\n### Key Features:\n- Works alongside existing IP-based rate limiting (both are enforced)\n- Separate counters per Telegram user\n- Configurable limits via environment variables\n- Friendly error messages with time remaining\n- Automatic cleanup to prevent memory issues\n- Enhanced logging for monitoring\n\n### Testing Status:\nThe implementation is complete and ready for testing with multiple users and rapid message scenarios.\n</info added on 2025-06-18T18:03:32.197Z>",
        "testStrategy": "1. Test with rapid sequential requests from the same Telegram user ID\n2. Verify rate limit message is sent when user limit is exceeded\n3. Confirm user counter resets after the time window expires\n4. Test that different Telegram users have separate rate limit counters\n5. Verify /start command bypasses user-based rate limiting\n6. Test with different user rate limit configurations\n7. Verify memory cleanup works by monitoring the userRequests object size\n8. Test the interaction between IP-based and user-based rate limiting\n9. Verify that IP-based rate limiting still works as expected\n10. Test with multiple users from the same IP address to ensure both limiting mechanisms work correctly",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Error Handling and Logging",
        "description": "Enhance existing error handling and implement comprehensive logging to ensure the bot operates reliably and issues can be diagnosed.",
        "status": "done",
        "dependencies": [
          3,
          4
        ],
        "priority": "medium",
        "details": "## Current Implementation\nThe application already has:\n- Basic error handling in forwardToN8n with timeout/network/n8n error scenarios\n- Basic console.log statements throughout the code\n- Error responses to users with appropriate messages\n\n## Enhancement Tasks\n\n1. Install a logging package:\n   ```bash\n   npm install winston\n   ```\n\n2. Set up a logger module (create logger.js):\n   ```javascript\n   const winston = require('winston');\n   \n   // Configure logger\n   const logger = winston.createLogger({\n     level: process.env.LOG_LEVEL || 'info',\n     format: winston.format.combine(\n       winston.format.timestamp(),\n       winston.format.json()\n     ),\n     defaultMeta: { service: 'telegram-bot-bridge' },\n     transports: [\n       // Console transport\n       new winston.transports.Console({\n         format: winston.format.combine(\n           winston.format.colorize(),\n           winston.format.simple()\n         )\n       }),\n       // File transport for errors\n       new winston.transports.File({ \n         filename: 'error.log', \n         level: 'error' \n       }),\n       // File transport for all logs\n       new winston.transports.File({ \n         filename: 'combined.log' \n       })\n     ]\n   });\n   \n   module.exports = logger;\n   ```\n\n3. Implement global error handling in index.js:\n   ```javascript\n   const logger = require('./logger');\n   \n   // Uncaught exception handler\n   process.on('uncaughtException', (error) => {\n     logger.error('Uncaught exception:', error);\n     // Keep the process alive but log the error\n   });\n   \n   // Unhandled promise rejection handler\n   process.on('unhandledRejection', (reason, promise) => {\n     logger.error('Unhandled promise rejection:', reason);\n   });\n   \n   // Express error handler\n   app.use((err, req, res, next) => {\n     logger.error('Express error:', { \n       error: err.message, \n       stack: err.stack,\n       path: req.path,\n       method: req.method\n     });\n     res.status(500).send('Internal server error');\n   });\n   ```\n\n4. Replace existing console.log/error calls with structured logger:\n   ```javascript\n   // Replace console.log/error calls with logger\n   // For example:\n   \n   // Before:\n   console.log(`Received message from ${userId}: ${messageText}`);\n   \n   // After:\n   logger.info('Received message', { userId, messageText });\n   \n   // Before:\n   console.error('Error processing webhook:', error);\n   \n   // After:\n   logger.error('Error processing webhook', { error: error.message, stack: error.stack });\n   ```\n\n5. Enhance existing error handling in forwardToN8n function:\n   ```javascript\n   // Update forwardToN8n function with enhanced error handling\n   async function forwardToN8n(message, userId) {\n     try {\n       // Existing code...\n     } catch (error) {\n       logger.error('Error forwarding to n8n', { \n         error: error.message, \n         userId,\n         messageLength: message.length,\n         stack: error.stack \n       });\n       \n       // Enhanced error classification (building on existing basic handling)\n       if (error.code === 'ECONNABORTED') {\n         logger.warn('n8n request timeout', { userId });\n         return { error: 'timeout', message: 'Request took too long, please try again' };\n       } else if (error.code === 'ECONNREFUSED') {\n         logger.error('n8n connection refused', { userId });\n         return { error: 'n8n_down', message: \"I'm having trouble thinking right now, try again in a moment\" };\n       } else if (error.response) {\n         logger.error('n8n error response', { \n           status: error.response.status,\n           data: error.response.data,\n           userId \n         });\n         if (error.response.status >= 500) {\n           return { error: 'n8n_error', message: \"I'm having trouble thinking right now, try again in a moment\" };\n         } else if (error.response.status === 429) {\n           return { error: 'n8n_rate_limited', message: \"I'm receiving too many requests right now, please try again later\" };\n         } else if (error.response.status === 400) {\n           return { error: 'invalid_request', message: \"I couldn't process that request properly\" };\n         }\n       }\n       \n       return { error: 'unknown', message: 'An error occurred processing your request' };\n     }\n   }\n   ```\n\n6. Add request logging middleware:\n   ```javascript\n   // Add to Express setup\n   app.use((req, res, next) => {\n     // Skip logging health checks to reduce noise\n     if (req.path === '/health') return next();\n     \n     const start = Date.now();\n     const requestId = crypto.randomUUID();\n     \n     // Add requestId to request object for tracking through the request lifecycle\n     req.requestId = requestId;\n     \n     logger.info('Request received', {\n       requestId,\n       method: req.method,\n       path: req.path,\n       query: req.query,\n       ip: req.ip\n     });\n     \n     // Log when request completes\n     res.on('finish', () => {\n       const duration = Date.now() - start;\n       logger.info('Request completed', {\n         requestId,\n         method: req.method,\n         path: req.path,\n         statusCode: res.statusCode,\n         duration: `${duration}ms`\n       });\n     });\n     \n     next();\n   });\n   ```\n\n7. Add environment-specific logging configuration:\n   ```javascript\n   // In logger.js, add environment-specific settings\n   const isProd = process.env.NODE_ENV === 'production';\n   \n   const logger = winston.createLogger({\n     level: process.env.LOG_LEVEL || (isProd ? 'info' : 'debug'),\n     // ... other config\n   });\n   \n   // Add development-specific formatting if not in production\n   if (!isProd) {\n     logger.add(new winston.transports.Console({\n       format: winston.format.combine(\n         winston.format.colorize(),\n         winston.format.prettyPrint(),\n         winston.format.splat(),\n         winston.format.simple()\n       )\n     }));\n   }\n   ```\n\n8. Add performance monitoring logs:\n   ```javascript\n   // Example for monitoring n8n response times\n   async function forwardToN8n(message, userId) {\n     const startTime = Date.now();\n     try {\n       // Existing code...\n       const response = await axios.post(...);\n       const duration = Date.now() - startTime;\n       \n       logger.info('n8n request completed', {\n         userId,\n         duration: `${duration}ms`,\n         status: response.status\n       });\n       \n       return response.data;\n     } catch (error) {\n       const duration = Date.now() - startTime;\n       logger.error('Error forwarding to n8n', { \n         error: error.message,\n         duration: `${duration}ms`,\n         userId,\n         // Other properties...\n       });\n       // Existing error handling...\n     }\n   }\n   ```\n<info added on 2025-06-18T18:22:56.253Z>\n## ✅ **Major Implementation Completed - Professional Logging & Error Handling:**\n\n## ✅ **Successfully Implemented:**\n\n### 1. **Professional Logger Module** (logger.js)\n- **Winston-based structured logging** with JSON format\n- **Multiple transports**: Console, combined.log, error.log\n- **Log rotation**: 5MB max file size, keeps 5 files\n- **Environment-aware**: Different formats for dev vs production\n- **Exception & rejection handling**: Automatic logging of crashes\n- **Request ID support**: Child logger functionality for request tracking\n\n### 2. **Request/Response Logging Middleware**\n- **Request tracking**: UUID-based request IDs for full request lifecycle\n- **Performance monitoring**: Duration tracking for all requests\n- **Context logging**: Method, path, IP, user agent\n- **Response logging**: Status codes and completion times\n- **Health check exclusion**: Reduces noise by skipping /health logs\n\n### 3. **Enhanced Error Handling**\n- **Global error handlers**: Uncaught exceptions and unhandled rejections\n- **Express error middleware**: Structured error responses\n- **Graceful shutdown**: SIGTERM and SIGINT handlers\n- **Production safety**: Exits on uncaught exceptions in production\n\n### 4. **Complete n8n Integration Logging**\n- **Performance tracking**: Request duration monitoring (up to 5-minute timeout)\n- **Enhanced error classification**: Timeout, connection, HTTP error detection\n- **Detailed error context**: Error codes, response data, stack traces\n- **Request correlation**: RequestId passed to n8n for full traceability\n- **Security-aware**: URL sanitization to hide sensitive endpoints\n\n### 5. **User Interaction Logging**\n- **Message processing**: Full request lifecycle tracking\n- **Rate limiting logs**: Detailed rate limit hit tracking\n- **User context**: User ID, name tracking without logging sensitive content\n- **Response performance**: Message length and processing time monitoring\n- **Telegram API logs**: Send success/failure with detailed error context\n\n### 6. **Structured Console Replacement**\n- **All console.log/error replaced**: Professional structured logging throughout\n- **Contextual data**: Every log includes relevant metadata\n- **Request correlation**: All logs include requestId when available\n- **Privacy-aware**: Message content length tracked, not content itself\n\n### 7. **Environment Configuration**\n- **LOG_LEVEL support**: Configurable via environment variables\n- **Development-friendly**: Colorized console output with timestamps\n- **Production-ready**: JSON logs for analysis tools\n- **Backward compatible**: Sensible defaults for missing configuration\n\n## 🔧 **Technical Features:**\n- **Auto log directory creation**: Creates logs/ folder automatically\n- **Memory efficient**: Log cleanup and rotation\n- **Error resilience**: Continues operating even with logging errors\n- **Request tracing**: Full request lifecycle visibility\n- **Performance insights**: Response time monitoring throughout the stack\n\n## 🛡️ **Security & Privacy:**\n- **No sensitive data logging**: User messages not logged, only metadata\n- **URL sanitization**: n8n endpoints partially hidden in logs\n- **Token protection**: No API tokens in log files\n- **User privacy**: Only user IDs and usernames logged, not message content\n\nThe bot now has enterprise-grade logging and error handling! 🚀\n</info added on 2025-06-18T18:22:56.253Z>",
        "testStrategy": "1. Test enhanced error handling by simulating various error conditions:\n   - n8n server down\n   - Network timeouts\n   - Invalid responses\n   - Malformed requests\n   - Rate limiting scenarios\n2. Verify logs are correctly written to files and console with appropriate log levels\n3. Check that uncaught exceptions are properly logged without crashing the application\n4. Test that request logging captures appropriate information including request IDs\n5. Verify different error types return the correct user-facing messages\n6. Test performance impact of logging by running load tests with and without detailed logging\n7. Verify environment-specific logging works correctly in development and production modes\n8. Check that sensitive information is not being logged (e.g., user messages, tokens)\n9. Test log rotation and ensure logs don't grow unbounded\n10. Verify that existing error handling functionality continues to work after enhancements",
        "subtasks": [
          {
            "id": "6.1",
            "title": "Replace console.log with winston logger",
            "status": "done"
          },
          {
            "id": "6.2",
            "title": "Implement structured logging with context",
            "status": "done"
          },
          {
            "id": "6.3",
            "title": "Enhance existing error handling in forwardToN8n",
            "status": "done"
          },
          {
            "id": "6.4",
            "title": "Add request/response logging middleware",
            "status": "done"
          },
          {
            "id": "6.5",
            "title": "Implement global error handlers",
            "status": "done"
          },
          {
            "id": "6.6",
            "title": "Add environment-specific logging configuration",
            "status": "done"
          },
          {
            "id": "6.7",
            "title": "Add performance monitoring logs",
            "status": "done"
          }
        ]
      },
      {
        "id": 7,
        "title": "Create Deployment Configuration",
        "description": "Prepare the application for deployment to Railway or Fly.io with proper configuration files and documentation.",
        "details": "1. Create a Dockerfile for containerized deployment:\n   ```dockerfile\n   FROM node:18-alpine\n   \n   WORKDIR /app\n   \n   # Copy package files and install dependencies\n   COPY package*.json ./\n   RUN npm ci --only=production\n   \n   # Copy application code\n   COPY . .\n   \n   # Set environment variables\n   ENV NODE_ENV=production\n   \n   # Expose the port\n   EXPOSE 3000\n   \n   # Start the application\n   CMD [\"node\", \"index.js\"]\n   ```\n\n2. Create a Railway configuration file (railway.json):\n   ```json\n   {\n     \"$schema\": \"https://railway.app/railway.schema.json\",\n     \"build\": {\n       \"builder\": \"NIXPACKS\",\n       \"buildCommand\": \"npm ci --only=production\"\n     },\n     \"deploy\": {\n       \"startCommand\": \"node index.js\",\n       \"healthcheckPath\": \"/health\",\n       \"healthcheckTimeout\": 10,\n       \"restartPolicyType\": \"ON_FAILURE\",\n       \"restartPolicyMaxRetries\": 10\n     }\n   }\n   ```\n\n3. Create a Fly.io configuration file (fly.toml):\n   ```toml\n   app = \"telegram-bot-bridge\"\n   \n   [build]\n     builder = \"heroku/buildpacks:20\"\n   \n   [env]\n     PORT = \"8080\"\n   \n   [http_service]\n     internal_port = 8080\n     force_https = true\n     auto_stop_machines = true\n     auto_start_machines = true\n     min_machines_running = 1\n     processes = [\"app\"]\n   \n   [[http_service.checks]]\n     grace_period = \"5s\"\n     interval = \"10s\"\n     method = \"GET\"\n     path = \"/health\"\n     protocol = \"http\"\n     timeout = \"2s\"\n   ```\n\n4. Create a .gitignore file:\n   ```\n   node_modules/\n   .env\n   *.log\n   npm-debug.log*\n   ```\n\n5. Update package.json with scripts:\n   ```json\n   \"scripts\": {\n     \"start\": \"node index.js\",\n     \"dev\": \"nodemon index.js\",\n     \"setup\": \"node setup.js\"\n   }\n   ```\n\n6. Create a setup.js script to register the webhook with Telegram:\n   ```javascript\n   require('dotenv').config();\n   const axios = require('axios');\n   const logger = require('./logger');\n   \n   async function setupWebhook() {\n     try {\n       const token = process.env.TELEGRAM_BOT_TOKEN;\n       const publicUrl = process.env.PUBLIC_URL;\n       \n       if (!token || !publicUrl) {\n         logger.error('Missing required environment variables: TELEGRAM_BOT_TOKEN or PUBLIC_URL');\n         process.exit(1);\n       }\n       \n       const webhookUrl = `${publicUrl}/webhook/telegram`;\n       const telegramUrl = `https://api.telegram.org/bot${token}/setWebhook?url=${encodeURIComponent(webhookUrl)}`;\n       \n       logger.info(`Setting webhook to: ${webhookUrl}`);\n       const response = await axios.get(telegramUrl);\n       \n       if (response.data.ok) {\n         logger.info('Webhook setup successful:', response.data);\n       } else {\n         logger.error('Webhook setup failed:', response.data);\n       }\n     } catch (error) {\n       logger.error('Error setting up webhook:', error);\n     }\n   }\n   \n   setupWebhook();\n   ```\n\n7. Create a README.md with deployment instructions:\n   ```markdown\n   # Telegram Bot Bridge for TON AI Strategist\n   \n   A simple Telegram bot bridge that forwards user messages to an n8n AI backend.\n   \n   ## Setup\n   \n   1. Clone the repository\n   2. Install dependencies: `npm install`\n   3. Create a `.env` file based on `.env.example`\n   4. Set the required environment variables:\n      - `TELEGRAM_BOT_TOKEN`: Get from BotFather\n      - `N8N_WEBHOOK_URL`: URL of your n8n webhook\n      - `PUBLIC_URL`: Public URL where your bot is deployed\n      - `PORT`: Port for the server (default: 3000)\n   \n   ## Deployment\n   \n   ### Railway\n   \n   1. Push code to GitHub\n   2. Create new project in Railway from GitHub repo\n   3. Add environment variables\n   4. Deploy\n   5. Run setup script: `railway run npm run setup`\n   \n   ### Fly.io\n   \n   1. Install Fly CLI: `curl -L https://fly.io/install.sh | sh`\n   2. Login: `fly auth login`\n   3. Launch app: `fly launch`\n   4. Set secrets: `fly secrets set TELEGRAM_BOT_TOKEN=your_token N8N_WEBHOOK_URL=your_url`\n   5. Deploy: `fly deploy`\n   6. Run setup: `fly ssh console -C \"npm run setup\"`\n   \n   ## Local Development\n   \n   1. Install dependencies: `npm install`\n   2. Start dev server: `npm run dev`\n   3. Use ngrok to expose local server: `ngrok http 3000`\n   4. Set PUBLIC_URL to ngrok URL in .env\n   5. Run setup: `npm run setup`\n   ```",
        "testStrategy": "1. Verify Dockerfile builds successfully\n2. Test deployment to Railway using the configuration file\n3. Test deployment to Fly.io using the configuration file\n4. Verify the setup script correctly registers the webhook\n5. Test the health check endpoint works as expected\n6. Confirm environment variables are properly loaded in the deployed environment\n7. Test automatic restarts on failure",
        "priority": "medium",
        "dependencies": [
          1,
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Testing and Final Integration",
        "description": "Create tests for the application and perform final integration testing with the n8n backend.",
        "status": "not needed",
        "dependencies": [
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "priority": "medium",
        "details": "1. Install testing dependencies:\n   ```bash\n   npm install --save-dev jest supertest nock\n   ```\n\n2. Create a test directory and test files:\n   ```bash\n   mkdir -p test\n   touch test/webhook.test.js\n   touch test/n8n.test.js\n   touch test/telegram.test.js\n   touch test/rate-limit.test.js\n   ```\n\n3. Create a basic test setup (test/webhook.test.js):\n   ```javascript\n   const request = require('supertest');\n   const nock = require('nock');\n   \n   // Mock environment variables\n   process.env.TELEGRAM_BOT_TOKEN = 'test_token';\n   process.env.N8N_WEBHOOK_URL = 'https://n8n.example.com/webhook';\n   \n   // Import the app (ensure app is exported from app.js)\n   const { app } = require('../app');\n   \n   describe('Telegram Webhook', () => {\n     beforeEach(() => {\n       // Mock Telegram API\n       nock('https://api.telegram.org')\n         .post(/\\/bot.*\\/sendMessage/)\n         .reply(200, { ok: true });\n       \n       // Mock n8n API with actual response format\n       nock('https://n8n.example.com')\n         .post('/webhook')\n         .reply(200, { \n           results: [\n             {\n               toolCallId: 'test-tool-call-id',\n               result: 'This is a test response from n8n'\n             }\n           ] \n         });\n     });\n     \n     afterEach(() => {\n       nock.cleanAll();\n     });\n     \n     test('Health check endpoint returns 200', async () => {\n       const response = await request(app).get('/health');\n       expect(response.status).toBe(200);\n       expect(response.body.status).toBe('ok');\n     });\n     \n     test('Webhook accepts valid Telegram message', async () => {\n       const response = await request(app)\n         .post('/webhook/telegram')\n         .send({\n           update_id: 123456789,\n           message: {\n             message_id: 123,\n             from: {\n               id: 12345,\n               first_name: 'Test',\n               username: 'testuser'\n             },\n             chat: {\n               id: 12345,\n               type: 'private'\n             },\n             date: Math.floor(Date.now() / 1000),\n             text: 'Hello, bot!'\n           }\n         });\n       \n       expect(response.status).toBe(200);\n     });\n     \n     test('Webhook rejects invalid request format', async () => {\n       const response = await request(app)\n         .post('/webhook/telegram')\n         .send({ invalid: 'format' });\n       \n       expect(response.status).toBe(400);\n     });\n   });\n   ```\n\n4. Create n8n integration tests (test/n8n.test.js):\n   ```javascript\n   const nock = require('nock');\n   \n   // Import the n8n service functions\n   const { forwardToN8n } = require('../services/n8n');\n   \n   describe('n8n Integration', () => {\n     beforeEach(() => {\n       process.env.N8N_WEBHOOK_URL = 'https://n8n.example.com/webhook';\n     });\n     \n     afterEach(() => {\n       nock.cleanAll();\n     });\n     \n     test('Successfully forwards message to n8n and extracts result', async () => {\n       nock('https://n8n.example.com')\n         .post('/webhook')\n         .reply(200, { \n           results: [\n             {\n               toolCallId: 'test-tool-call-id',\n               result: 'Test response'\n             }\n           ] \n         });\n       \n       const result = await forwardToN8n('Test message', 12345);\n       expect(result).toEqual('Test response');\n     });\n     \n     test('Handles n8n server error', async () => {\n       nock('https://n8n.example.com')\n         .post('/webhook')\n         .reply(500, { error: 'Internal server error' });\n       \n       const result = await forwardToN8n('Test message', 12345);\n       expect(result.error).toBe('n8n_error');\n     });\n     \n     test('Handles timeout', async () => {\n       nock('https://n8n.example.com')\n         .post('/webhook')\n         .delayConnection(11000) // Longer than our timeout\n         .reply(200, { \n           results: [\n             {\n               toolCallId: 'test-tool-call-id',\n               result: 'Delayed response'\n             }\n           ] \n         });\n       \n       const result = await forwardToN8n('Test message', 12345);\n       expect(result.error).toBe('timeout');\n     });\n     \n     test('Handles empty or invalid n8n response format', async () => {\n       nock('https://n8n.example.com')\n         .post('/webhook')\n         .reply(200, { invalidFormat: true });\n       \n       const result = await forwardToN8n('Test message', 12345);\n       expect(result.error).toBe('invalid_response');\n     });\n   });\n   ```\n\n5. Create rate limiting tests (test/rate-limit.test.js):\n   ```javascript\n   const request = require('supertest');\n   const nock = require('nock');\n   \n   // Import the app and rate limiting service\n   const { app } = require('../app');\n   const { checkRateLimit, resetRateLimits } = require('../services/rate-limit');\n   \n   describe('Rate Limiting', () => {\n     beforeEach(() => {\n       // Reset rate limits before each test\n       resetRateLimits();\n       \n       // Mock Telegram API\n       nock('https://api.telegram.org')\n         .persist()\n         .post(/\\/bot.*\\/sendMessage/)\n         .reply(200, { ok: true });\n       \n       // Mock n8n API\n       nock('https://n8n.example.com')\n         .persist()\n         .post('/webhook')\n         .reply(200, { \n           results: [\n             {\n               toolCallId: 'test-tool-call-id',\n               result: 'Test response'\n             }\n           ] \n         });\n     });\n     \n     afterEach(() => {\n       nock.cleanAll();\n     });\n     \n     test('User-specific rate limiting works correctly', async () => {\n       const userId = 12345;\n       const maxRequests = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || 5);\n       \n       // Should allow configured number of requests\n       for (let i = 0; i < maxRequests; i++) {\n         const isRateLimited = await checkRateLimit(userId);\n         expect(isRateLimited).toBe(false);\n       }\n       \n       // Should be rate limited after max requests\n       const isRateLimited = await checkRateLimit(userId);\n       expect(isRateLimited).toBe(true);\n     });\n     \n     test('Different users have separate rate limits', async () => {\n       const user1 = 11111;\n       const user2 = 22222;\n       const maxRequests = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || 5);\n       \n       // Max out first user\n       for (let i = 0; i < maxRequests; i++) {\n         await checkRateLimit(user1);\n       }\n       \n       // First user should be rate limited\n       expect(await checkRateLimit(user1)).toBe(true);\n       \n       // Second user should not be rate limited\n       expect(await checkRateLimit(user2)).toBe(false);\n     });\n     \n     test('Webhook endpoint enforces rate limits', async () => {\n       const userId = 33333;\n       const maxRequests = parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || 5);\n       \n       // Send max allowed requests\n       for (let i = 0; i < maxRequests; i++) {\n         const response = await request(app)\n           .post('/webhook/telegram')\n           .send({\n             update_id: 123456789,\n             message: {\n               message_id: 123,\n               from: {\n                 id: userId,\n                 first_name: 'Test',\n                 username: 'testuser'\n               },\n               chat: {\n                 id: userId,\n                 type: 'private'\n               },\n               date: Math.floor(Date.now() / 1000),\n               text: 'Test message'\n             }\n           });\n         \n         expect(response.status).toBe(200);\n       }\n       \n       // Next request should be rate limited\n       const response = await request(app)\n         .post('/webhook/telegram')\n         .send({\n           update_id: 123456789,\n           message: {\n             message_id: 123,\n             from: {\n               id: userId,\n               first_name: 'Test',\n               username: 'testuser'\n             },\n             chat: {\n               id: userId,\n               type: 'private'\n             },\n             date: Math.floor(Date.now() / 1000),\n             text: 'Test message'\n           }\n         });\n       \n       expect(response.status).toBe(429); // Too Many Requests\n     });\n   });\n   ```\n\n6. Create message processing tests (test/message-processing.test.js):\n   ```javascript\n   const nock = require('nock');\n   \n   // Import the message processing function\n   const { processMessage } = require('../services/message-processor');\n   const { sendTelegramMessage } = require('../services/telegram');\n   \n   // Mock dependencies\n   jest.mock('../services/telegram', () => ({\n     sendTelegramMessage: jest.fn().mockResolvedValue({ ok: true })\n   }));\n   \n   describe('Message Processing Pipeline', () => {\n     beforeEach(() => {\n       // Reset mocks\n       jest.clearAllMocks();\n       \n       // Mock n8n API\n       nock('https://n8n.example.com')\n         .post('/webhook')\n         .reply(200, { \n           results: [\n             {\n               toolCallId: 'test-tool-call-id',\n               result: 'Processed response'\n             }\n           ] \n         });\n     });\n     \n     afterEach(() => {\n       nock.cleanAll();\n     });\n     \n     test('Processes message and sends response', async () => {\n       const telegramMessage = {\n         message_id: 123,\n         from: {\n           id: 12345,\n           first_name: 'Test',\n           username: 'testuser'\n         },\n         chat: {\n           id: 12345,\n           type: 'private'\n         },\n         date: Math.floor(Date.now() / 1000),\n         text: 'Test message'\n       };\n       \n       await processMessage(telegramMessage);\n       \n       // Verify Telegram message was sent with processed response\n       expect(sendTelegramMessage).toHaveBeenCalledWith(\n         12345,\n         'Processed response'\n       );\n     });\n     \n     test('Handles error in processing pipeline', async () => {\n       // Mock n8n error\n       nock.cleanAll();\n       nock('https://n8n.example.com')\n         .post('/webhook')\n         .reply(500, { error: 'Internal server error' });\n       \n       const telegramMessage = {\n         message_id: 123,\n         from: {\n           id: 12345,\n           first_name: 'Test',\n           username: 'testuser'\n         },\n         chat: {\n           id: 12345,\n           type: 'private'\n         },\n         date: Math.floor(Date.now() / 1000),\n         text: 'Test message'\n       };\n       \n       await processMessage(telegramMessage);\n       \n       // Verify error message was sent\n       expect(sendTelegramMessage).toHaveBeenCalledWith(\n         12345,\n         expect.stringContaining('Sorry, I encountered an error')\n       );\n     });\n   });\n   ```\n\n7. Update package.json with test script:\n   ```json\n   \"scripts\": {\n     \"test\": \"jest\",\n     \"test:watch\": \"jest --watch\",\n     \"test:coverage\": \"jest --coverage\",\n     \"start\": \"node index.js\",\n     \"dev\": \"nodemon index.js\",\n     \"setup\": \"node setup.js\"\n   }\n   ```\n\n8. Create an integration test script (test-integration.js):\n   ```javascript\n   require('dotenv').config();\n   const axios = require('axios');\n   const logger = require('./utils/logger');\n   \n   // Test messages to send\n   const TEST_MESSAGES = [\n     '/start',\n     'What is TON?',\n     'Tell me about crypto market trends',\n     'How does staking work?'\n   ];\n   \n   async function runIntegrationTest() {\n     try {\n       const token = process.env.TELEGRAM_BOT_TOKEN;\n       const chatId = process.env.TEST_CHAT_ID;\n       \n       if (!token || !chatId) {\n         logger.error('Missing required environment variables for integration test');\n         process.exit(1);\n       }\n       \n       logger.info('Starting integration test');\n       \n       // Send test messages\n       for (const message of TEST_MESSAGES) {\n         logger.info(`Testing message: ${message}`);\n         \n         // Simulate incoming message\n         const webhookPayload = {\n           update_id: Date.now(),\n           message: {\n             message_id: Date.now(),\n             from: {\n               id: chatId,\n               first_name: 'Test',\n               username: 'testuser'\n             },\n             chat: {\n               id: chatId,\n               type: 'private'\n             },\n             date: Math.floor(Date.now() / 1000),\n             text: message\n           }\n         };\n         \n         // Send to local webhook\n         await axios.post('http://localhost:3000/webhook/telegram', webhookPayload);\n         \n         // Wait for processing\n         await new Promise(resolve => setTimeout(resolve, 5000));\n       }\n       \n       logger.info('Integration test completed');\n     } catch (error) {\n       logger.error('Integration test failed:', error);\n     }\n   }\n   \n   runIntegrationTest();\n   ```\n\n9. Add integration test script to package.json:\n   ```json\n   \"scripts\": {\n     \"test\": \"jest\",\n     \"test:watch\": \"jest --watch\",\n     \"test:coverage\": \"jest --coverage\",\n     \"test:integration\": \"node test-integration.js\",\n     \"start\": \"node index.js\",\n     \"dev\": \"nodemon index.js\",\n     \"setup\": \"node setup.js\"\n   }\n   ```\n\n10. Ensure proper exports in app.js for testing:\n    ```javascript\n    // At the end of app.js\n    module.exports = { app };\n    ```\n\n11. Ensure proper exports in service files:\n    ```javascript\n    // In services/n8n.js\n    module.exports = { forwardToN8n };\n    \n    // In services/telegram.js\n    module.exports = { sendTelegramMessage };\n    \n    // In services/rate-limit.js\n    module.exports = { checkRateLimit, resetRateLimits };\n    \n    // In services/message-processor.js\n    module.exports = { processMessage };\n    ```",
        "testStrategy": "1. Run unit tests with Jest to verify individual components\n2. Test the webhook endpoint with mock requests\n3. Test n8n integration with mocked responses using the actual n8n response format (results array with toolCallId and result)\n4. Test Telegram API integration with mocked responses\n5. Test user-based rate limiting functionality with different test users\n6. Test the complete message processing pipeline from Telegram to n8n and back\n7. Run the integration test script against a local development server\n8. Perform manual testing with a real Telegram bot and n8n instance\n9. Verify all error handling scenarios work as expected, including invalid n8n responses\n10. Test the end-to-end flow: Telegram → Express.js → n8n → Express.js → Telegram",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Wallet Address Detection",
        "description": "Develop a system to detect and validate TON and Ethereum wallet addresses in user messages.",
        "details": "1. Install and configure crypto-regex library (version 1.1.0 or later) for wallet address detection.\n2. Implement regex patterns for TON and Ethereum addresses.\n3. Create a utility function in wallet-utils.js to detect and validate addresses:\n   ```javascript\n   const { tonAddressRegex, ethAddressRegex } = require('crypto-regex');\n   \n   function detectWalletAddress(message) {\n     const tonMatch = message.match(tonAddressRegex);\n     if (tonMatch) return { type: 'TON', address: tonMatch[0] };\n     \n     const ethMatch = message.match(ethAddressRegex);\n     if (ethMatch) return { type: 'ETH', address: ethMatch[0] };\n     \n     return null;\n   }\n   ```\n4. Integrate the detection function into the main message processing flow in index.js.\n5. Implement error handling for invalid addresses.",
        "testStrategy": "1. Unit test the detectWalletAddress function with various input scenarios.\n2. Integration test the wallet detection in the main message flow.\n3. Test with intentionally malformed addresses to ensure proper error handling.",
        "priority": "high",
        "dependencies": [],
        "status": "handled by n8n",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Integrate TON API for Wallet Data Retrieval",
        "description": "Implement TON API integration to fetch wallet balances and token holdings for detected TON addresses.",
        "details": "1. Install ton-core (version 0.49.0 or later) and @orbs-network/ton-access (version 1.3.0 or later) packages.\n2. Create ton-api.js file for TON blockchain integration:\n   ```javascript\n   const { TonClient } = require('ton');\n   const { getHttpEndpoint } = require('@orbs-network/ton-access');\n   \n   async function getTonWalletData(address) {\n     const endpoint = await getHttpEndpoint();\n     const client = new TonClient({ endpoint });\n     const balance = await client.getBalance(address);\n     // Fetch token data (implement based on TON token standards)\n     return { balance, tokens: [] };\n   }\n   ```\n3. Implement error handling and retries for API calls.\n4. Add TON_API_ENDPOINT to .env file and update .env.example.\n5. Create a wrapper function in wallet-utils.js to handle both TON and ETH addresses (ETH implementation as a placeholder for now).\n<info added on 2025-06-18T20:56:46.253Z>\n## TON Wallet Address Detection and Data Retrieval Implementation\n\n### Address Detection\nAdd a regex pattern for TON wallet address detection:\n```javascript\n// In wallet-utils.js\nconst TON_ADDRESS_REGEX = /(?:EQ|UQ|kQ|(?:-1:|0:))?[A-Za-z0-9_-]{48}/g;\n\nfunction detectWalletAddress(message) {\n  const tonMatch = message.match(TON_ADDRESS_REGEX);\n  if (tonMatch) return { type: 'TON', address: tonMatch[0] };\n  \n  // Existing ETH detection logic\n  const ethMatch = message.match(/\\b0x[a-fA-F0-9]{40}\\b/g);\n  if (ethMatch) return { type: 'ETH', address: ethMatch[0] };\n  \n  return null;\n}\n```\n\n### Enhanced TON API Integration\nUpdate the ton-api.js implementation:\n```javascript\nconst { TonClient } = require('ton');\nconst { getHttpEndpoint } = require('@orbs-network/ton-access');\n\nasync function getTonWalletData(address) {\n  try {\n    // Validate address format before proceeding\n    if (!address.match(/[A-Za-z0-9_-]{48}/)) {\n      throw new Error('Invalid TON address format');\n    }\n    \n    // Get endpoint with retry logic\n    const endpoint = await getHttpEndpoint({ network: 'mainnet' });\n    const client = new TonClient({ endpoint });\n    \n    // Get basic balance\n    const balance = await client.getBalance(address);\n    \n    // For token holdings, implement Jetton standard support\n    // This requires additional contract interactions\n    const tokens = await fetchJettonBalances(client, address);\n    \n    return { \n      balance: balance.toString(), \n      tokens,\n      address\n    };\n  } catch (error) {\n    console.error(`TON API error: ${error.message}`);\n    // Implement exponential backoff retry logic here\n    throw new Error(`Failed to retrieve TON wallet data: ${error.message}`);\n  }\n}\n\nasync function fetchJettonBalances(client, address) {\n  // Placeholder for Jetton token implementation\n  // Will require JettonWallet contract interactions\n  return [];\n}\n```\n\n### Performance Optimization\nImplement caching to reduce API calls:\n```javascript\n// Simple in-memory cache with TTL\nconst walletCache = new Map();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\nasync function getCachedTonWalletData(address) {\n  const cacheKey = `ton:${address}`;\n  const cached = walletCache.get(cacheKey);\n  \n  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {\n    return cached.data;\n  }\n  \n  const data = await getTonWalletData(address);\n  walletCache.set(cacheKey, {\n    timestamp: Date.now(),\n    data\n  });\n  \n  return data;\n}\n```\n\n### Testing Strategy\nAdd unit tests for address detection and API integration:\n- Test with valid and invalid TON addresses\n- Test with different address formats (with/without workchain prefix)\n- Mock API responses for predictable testing\n- Test error handling and retry logic\n</info added on 2025-06-18T20:56:46.253Z>\n<info added on 2025-06-18T21:00:34.633Z>\n## Implementation Completion Report\n\nThe TON API integration for wallet data retrieval has been successfully completed with all requirements fulfilled:\n\n### Completed Implementation\n- Created wallet-utils.js with comprehensive wallet detection and TON API integration\n- Installed required packages: @orbs-network/ton-access, ton-core\n- Implemented wallet address detection using regex patterns for TON (48 chars) and ETH (42 chars)\n- Added getTonWalletData() function with:\n  - Optimal endpoint selection via @orbs-network/ton-access\n  - Wallet balance fetching using ton-core TonClient\n  - nanoTON to TON conversion for user-friendly display\n  - Comprehensive error handling and logging\n- Integrated wallet detection into main message processing flow in index.js\n- Added formatWalletResponse() to create user-friendly Telegram messages\n- Updated env.example with TON_API_ENDPOINT configuration\n\n### Key Features\n- Direct wallet address detection in user messages (bypassing n8n forwarding)\n- Real-time TON wallet balance retrieval using official APIs\n- User-friendly balance display with personalized response: \"You have X TON, want analysis?\"\n- Graceful error handling with fallback to general crypto questions\n- Performance optimization with <5 second response time target\n- Comprehensive logging for monitoring and debugging\n\n### Workflow Implementation\nThe integration follows the specified architecture where ExpressJS handles wallet detection and balance fetching directly without sending wallet addresses to n8n:\n1. Educational queries → ExpressJS → n8n (existing flow)\n2. User sends TON address → ExpressJS detects → fetches balance → responds directly\n3. User can request strategy analysis (will go to n8n with wallet context)\n</info added on 2025-06-18T21:00:34.633Z>",
        "testStrategy": "1. Unit test the getTonWalletData function with mock API responses.\n2. Integration test with real TON testnet addresses.\n3. Test error scenarios (API unavailable, rate limiting, etc.).\n4. Benchmark API call performance to ensure <5 second response time.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Enhance n8n Payload with Wallet Context",
        "description": "Modify the existing n8n webhook integration to include wallet data in the payload for personalized responses.",
        "details": "1. Update the n8n webhook payload structure in index.js:\n   ```javascript\n   const payload = {\n     question: userMessage,\n     userId: telegramUserId,\n     walletData: walletInfo ? {\n       type: walletInfo.type,\n       balance: walletInfo.balance,\n       tokens: walletInfo.tokens\n     } : null\n   };\n   ```\n2. Modify the n8n workflow to handle the new payload structure:\n   - Add a decision node to check for wallet data presence\n   - Implement separate paths for messages with and without wallet data\n3. Update error handling to account for potential issues with the new payload structure.",
        "testStrategy": "1. Unit test the payload creation function with various input scenarios.\n2. Integration test the enhanced n8n webhook call.\n3. Verify that n8n correctly processes both wallet-enhanced and regular payloads.\n4. Test error scenarios (missing wallet data, malformed payload, etc.).",
        "priority": "medium",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Market Sentiment Analysis Integration",
        "description": "Enhance the n8n workflow to incorporate real-time market sentiment analysis for personalized strategy recommendations.",
        "details": "1. Set up API integrations in n8n for market data sources:\n   - Reddit API (PRAW library, version 7.7.0 or later)\n   - Twitter API (twitter-api-v2 library, version 1.15.0 or later)\n   - News API (newsapi library, version 2.4.1 or later)\n2. Create a sentiment analysis node in n8n using TextBlob (version 0.15.3 or later) for natural language processing.\n3. Implement a custom node for aggregating sentiment scores:\n   ```javascript\n   function aggregateSentiment(redditScore, twitterScore, newsScore) {\n     const weights = { reddit: 0.3, twitter: 0.4, news: 0.3 };\n     return (redditScore * weights.reddit + twitterScore * weights.twitter + newsScore * weights.news) / 3;\n   }\n   ```\n4. Integrate the sentiment score into the strategy generation logic.\n5. Implement caching for API responses to manage rate limits and improve performance.",
        "testStrategy": "1. Unit test the sentiment analysis and aggregation functions.\n2. Integration test the entire market sentiment workflow in n8n.\n3. Benchmark performance to ensure sentiment analysis doesn't significantly impact response time.\n4. Test with various market conditions to verify appropriate strategy adjustments.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Develop Personalized Strategy Generation",
        "description": "Create an AI-powered system to generate personalized investment strategies based on wallet holdings and market sentiment.",
        "details": "1. Implement a strategy generation function in n8n:\n   ```javascript\n   function generateStrategy(walletData, marketSentiment) {\n     const { balance, tokens } = walletData;\n     const totalValue = calculateTotalValue(balance, tokens);\n     \n     let strategy = [];\n     \n     if (totalValue < 1000) {\n       strategy.push('Consider dollar-cost averaging to build your portfolio');\n     } else if (totalValue < 10000) {\n       strategy.push(`Stake ${Math.floor(balance * 0.5)} TON for passive income`);\n     } else {\n       strategy.push('Diversify your portfolio across different token types');\n     }\n     \n     if (marketSentiment > 0.6) {\n       strategy.push('Market sentiment is positive. Consider increasing your positions.');\n     } else if (marketSentiment < 0.4) {\n       strategy.push('Market sentiment is cautious. Consider holding or taking profits.');\n     }\n     \n     return strategy.join('\\n');\n   }\n   ```\n2. Integrate the strategy generation with the existing n8n workflow.\n3. Implement safeguards to ensure strategies are appropriate for the user's portfolio size.\n4. Create templates for strategy presentation in user-friendly format.",
        "testStrategy": "1. Unit test the strategy generation function with various input scenarios.\n2. Integration test the strategy generation within the n8n workflow.\n3. Conduct user acceptance testing to ensure strategies are clear and actionable.\n4. Verify that generated strategies align with best practices in crypto investment.",
        "priority": "high",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Enhanced User Interface and Error Handling",
        "description": "Upgrade the Telegram bot interface to support new features and implement comprehensive error handling for all scenarios.",
        "details": "1. Update the main message handling function in index.js:\n   ```javascript\n   async function handleMessage(msg) {\n     const walletInfo = detectWalletAddress(msg.text);\n     if (walletInfo) {\n       try {\n         const walletData = await getWalletData(walletInfo);\n         // Process wallet data\n       } catch (error) {\n         return handleWalletError(error);\n       }\n     }\n     // Existing message processing logic\n   }\n   ```\n2. Implement new command handlers:\n   - /wallet - Prompt user to share wallet address\n   - /strategy - Generate personalized strategy\n   - /sentiment - Display current market sentiment\n3. Enhance error handling:\n   - Invalid wallet address: \"That doesn't look like a valid wallet address. Please check and try again.\"\n   - API unavailable: \"I'm having trouble accessing blockchain data right now. Please try again later.\"\n   - Rate limiting: \"You've made too many requests. Please wait a moment before trying again.\"\n4. Implement inline keyboard for strategy options:\n   ```javascript\n   const keyboard = {\n     inline_keyboard: [\n       [{ text: \"Get Strategy\", callback_data: \"strategy\" }],\n       [{ text: \"Market Sentiment\", callback_data: \"sentiment\" }]\n     ]\n   };\n   ```\n5. Update the response formatting to support rich text and keyboard options.",
        "testStrategy": "1. Unit test new command handlers and error handling functions.\n2. Integration test the enhanced message flow with various user inputs.\n3. Conduct end-to-end testing of the complete user journey, including error scenarios.\n4. Perform usability testing to ensure the new interface is intuitive and responsive.",
        "priority": "medium",
        "dependencies": [
          10,
          11,
          12,
          13
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-18T13:40:24.620Z",
      "updated": "2025-06-18T21:00:51.213Z",
      "description": "Tasks for master context"
    }
  }
}